__kf_norm_kind() {
  case "${1:-}" in
    po|pod|pods)                     echo "pods" ;;
    deploy|deployment|deployments)   echo "deployments" ;;
    svc|service|services)            echo "services" ;;
    *)                               echo "" ;;
  esac
}

__kf_ns_scope_from_lbuf() {
  local lbuf="$1"
  if [[ "$lbuf" == *" -A"* || "$lbuf" == *" --all-namespaces"* ]]; then
    echo "-A"; return
  fi
  if [[ "$lbuf" == *"--namespace="* ]]; then
    printf -- "-n %s" "${lbuf##*--namespace=}" | awk '{print "-n",$1}'
    return
  fi
  local tokens=(${(z)lbuf})
  for ((i=1; i<=${#tokens[@]}; i++)); do
    if [[ "${tokens[i]}" == "-n" || "${tokens[i]}" == "--namespace" ]]; then
      local j=$((i+1))
      [[ $j -le ${#tokens[@]} ]] && printf -- "-n %s" "${tokens[j]}"
      return
    fi
  done
  echo ""
}

# Strict TAB-separated "NS<TAB>NAME"
__kf_list() {
  local kind="$1"; shift
  local scope="$1"; shift || true

  if [[ "$scope" == "-A" ]]; then
    kubectl get "$kind" -A -o jsonpath='{range .items[*]}{.metadata.namespace}{"\t"}{.metadata.name}{"\n"}{end}' 2>/dev/null
  else
    local cns
    cns=$(kubectl config view --minify -o jsonpath='{..namespace}' 2>/dev/null || true)
    [[ -z "$cns" ]] && cns=default
    kubectl get "$kind" ${=scope} -o jsonpath='{range .items[*]}{.metadata.namespace}{"\t"}{.metadata.name}{"\n"}{end}' 2>/dev/null \
    | awk -v ns="$cns" -F'\t' 'BEGIN{OFS="\t"} { if($1=="") $1=ns; print $1,$2 }'
  fi
}

__kf_preview() {
  local action="$1" kind="$2"
  case "$action" in
    get)
      cat <<EOF
bash -c '
ns=\$1; name=\$2; kind=\$3;
kubectl get "\$kind" -n "\$ns" "\$name" -o yaml 2>&1
' preview {1} {2} $kind
EOF
      ;;
    describe)
      cat <<EOF
bash -c '
ns=\$1; name=\$2; kind=\$3;
kubectl describe "\$kind" -n "\$ns" "\$name"
' preview {1} {2} $kind
EOF
      ;;
    logs)
      cat <<'EOF'
bash -c '
ns=$1; name=$2;
kubectl logs -n "$ns" "$name" --all-containers --tail=200 2>&1
' preview {1} {2}
EOF
      ;;
  esac
}

# Remove resource kind token (3rd token) from a kubectl line
__kf_strip_kind_token_if_present() {
  local lbuf="$1" kind="$2"
  local tokens=(${(z)lbuf})
  if (( ${#tokens[@]} >= 3 )) && [[ "${tokens[3]}" == (#i)(po|pod|pods|deploy|deployment|deployments|svc|service|services) ]]; then
    tokens=("${tokens[1]}" "${tokens[2]}" "${(@)tokens[4,-1]}")
  fi
  echo "${(j: :)tokens}"
}

_fzf_complete_kubectl() {
  setopt localoptions noshwordsplit noksh_arrays
  local lbuf="$1"

  # Strip trigger token (e.g., ",") if present at tail and dangling commas/spaces
  if [[ -n "$FZF_COMPLETION_TRIGGER" && "$lbuf" == *"$FZF_COMPLETION_TRIGGER" ]]; then
    lbuf="${lbuf%$FZF_COMPLETION_TRIGGER}"
  fi
  lbuf="${lbuf%%+([[:space:],;:])}"
  LBUFFER="${lbuf% } "

  local tokens=(${(z)LBUFFER})
  local sub="${tokens[2]:-}"          # get|describe|logs
  local raw_kind="${tokens[3]:-}"
  local kind="$(__kf_norm_kind "$raw_kind")"

  # Allow logs/describe to omit kind: default to pods for logs; require known kind for describe/get
  if [[ "$sub" == "logs" && -z "$kind" ]]; then
    kind="pods"
  fi
  [[ -z "$sub" || "$sub" != (get|describe|logs) ]] && return
  if [[ "$sub" != "logs" && -z "$kind" ]]; then
    return
  fi
  if [[ "$sub" == "logs" ]]; then
    # kubectl logs syntax has no kind token; strip it if present
    local stripped
    stripped="$(__kf_strip_kind_token_if_present "$LBUFFER" "$kind")"
    LBUFFER="${stripped% } "
    lbuf="$LBUFFER"
    # re-tokenize after strip
    tokens=(${(z)LBUFFER})
  fi

  local scope; scope="$(__kf_ns_scope_from_lbuf "$LBUFFER")"
  local list; list="$(__kf_list "$kind" "$scope")"
  [[ -z "$list" ]] && return

  local preview; preview="$(__kf_preview "$sub" "$kind")"
  local selected
  selected=$(echo "$list" | FZF_DEFAULT_COMMAND='' fzf \
    --ansi --with-nth=1,2 --delimiter=$'\t' \
    --header "TAB: insert â€¢ ENTER: insert+execute" \
    --preview "$preview" --preview-window=right:70%:wrap \
    --expect=enter,tab --multi --height=80% --reverse) || return

  local key; key=$(echo "$selected" | head -1)
  local rows; rows=$(echo "$selected" | tail -n +2)
  [[ -z "$rows" ]] && { zle reset-prompt; return; }

  local out=""; local add_container_flag=""
  if [[ "$sub" == "logs" ]]; then
    if [[ "$LBUFFER" == *" -c "* || "$LBUFFER" == *"--container="* || "$LBUFFER" == *" --container "* ]]; then
      add_container_flag=""
    else
      add_container_flag=" --all-containers"
    fi
  fi

  while IFS=$'\t' read -r ns name; do
    [[ -z "$ns" || -z "$name" ]] && continue
    if [[ "$scope" == "-A" ]]; then
      case "$sub" in
        get|describe) out+=" -n ${ns} ${name}" ;;
        logs)         out+=" -n ${ns} ${name}${add_container_flag}" ;;
      esac
    else
      case "$sub" in
        get|describe) out+=" ${name}" ;;
        logs)         out+=" ${name}${add_container_flag}" ;;
      esac
    fi
  done <<<"$rows"

  [[ -z "$out" ]] && { zle reset-prompt; return; }
  LBUFFER+="$out "
  zle reset-prompt
  [[ "$key" == "enter" ]] && zle accept-line
}

_fzf_complete_k()            { _fzf_complete_kubectl "$1"; }
_fzf_complete_kubectl_post() { awk '{print $0}'; }
_fzf_complete_k_post()       { _fzf_complete_kubectl_post; }
_fzf_complete_kgp()          { _fzf_complete_kubectl "kubectl get pods ${LBUFFER#*kubectl get pods }"; }
_fzf_complete_kgd()          { _fzf_complete_kubectl "kubectl get deployments ${LBUFFER#*kubectl get deployments }"; }
_fzf_complete_kgs()          { _fzf_complete_kubectl "kubectl get services ${LBUFFER#*kubectl get services }"; }
_fzf_complete_kdp()          { _fzf_complete_kubectl "kubectl describe pods ${LBUFFER#*kubectl describe pods }"; }
_fzf_complete_kdl()          { _fzf_complete_kubectl "kubectl describe deployments ${LBUFFER#*kubectl describe deployments }"; }
_fzf_complete_kds()          { _fzf_complete_kubectl "kubectl describe services ${LBUFFER#*kubectl describe services }"; }
_fzf_complete_kl()           { _fzf_complete_kubectl "kubectl logs ${LBUFFER#*kubectl logs }"; }  # logs has no kind token
